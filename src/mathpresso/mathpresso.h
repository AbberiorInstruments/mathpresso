// [MathPresso]
// Mathematical Expression Parser and JIT Compiler.
//
// [License]
// Zlib - See LICENSE.md file in the package.

// [Guard]
#ifndef _MATHPRESSO_H
#define _MATHPRESSO_H

#include <stdlib.h>
#include <iostream>
#include <complex>
#include <vector>
#include <map>
#include <memory>
#include <algorithm>

#if !defined(_MSC_VER)
#include <stdint.h>
#endif

// uncomment, if you want to use the same syntax for function-calls.
// #define MATHPRESSO_ORIGINAL_DOUBLE_FUNCTION_CALLS

namespace mathpresso
{

	// ============================================================================
	// [mathpresso::Configuration]
	// ============================================================================

	// EMBED implies STATIC.
#if defined(MATHPRESSO_EMBED) && !defined(MATHPRESSO_STATIC)
# define MATHPRESSO_STATIC
#endif

// ============================================================================
// [mathpresso::PPDefs]
// ============================================================================

//! \def MATHPRESSO_API
//!
//! Mathpresso API decorator.
#if !defined(MATHPRESSO_API)
# if defined(MATHPRESSO_STATIC)
#  define MATHPRESSO_API
# elif defined(_WINDOWS)
#  if defined(__GNUC__) || defined(__clang__) && !defined(__MINGW32__)
#   if defined(MATHPRESSO_EXPORTS)
#    define MATHPRESSO_API __attribute__((__dllexport__))
#   else
#    define MATHPRESSO_API __attribute__((__dllimport__))
#   endif
#  else
#   if defined(MATHPRESSO_EXPORTS)
#    define MATHPRESSO_API __declspec(dllexport)
#   else
#    define MATHPRESSO_API __declspec(dllimport)
#   endif
#  endif
# else
#  if defined(__clang__) || defined(__GNUC__)
#   define MATHPRESSO_API __attribute__((__visibility__("default")))
#  endif
# endif
#endif

#define MATHPRESSO_NO_COPY(type) \
type(const type& other) = delete; \
type& operator=(const type& other) = delete; \

//! Get an offset of `field` in a struct `type`.
#define MATHPRESSO_OFFSET(type, field) \
  ((int)(size_t) ((const char*) &((const type*)0x10)->field) - 0x10)

#define MATHPRESSO_ARRAY_SIZE(array) \
  (sizeof(array) / sizeof(array[0]))

// ============================================================================
// [Forward Declarations]
// ============================================================================

	struct OutputLog;
	struct Expression;
	struct AstSymbol;

	class MpOperation;
	class Symbols;

	// ============================================================================
	// [mathpresso::TypeDefs]
	// ============================================================================

	//! MathPresso result type (signed integer).
	typedef unsigned int Error;

	//! Prototype of the compiled function generated by MathPresso.
	typedef void(*CompiledFunc)(double* result, void* data);


#ifdef MATHPRESSO_ORIGINAL_DOUBLE_FUNCTION_CALLS
	typedef double(*Arg0Func)();
	typedef double(*Arg1Func)(double);
	typedef double(*Arg2Func)(double, double);
	typedef double(*Arg3Func)(double, double, double);
	typedef double(*Arg4Func)(double, double, double, double);
	typedef double(*Arg5Func)(double, double, double, double, double);
	typedef double(*Arg6Func)(double, double, double, double, double, double);
	typedef double(*Arg7Func)(double, double, double, double, double, double, double);
	typedef double(*Arg8Func)(double, double, double, double, double, double, double, double);
#endif 

	typedef double(*mpFuncDtoD)(const double*);
	typedef std::complex<double>(*mpFuncpCtoC)(const std::complex<double>*);
	typedef double(*mpFuncpCtoD)(const std::complex<double>*);
	typedef std::complex<double>(*mpFuncpDtoC)(const double*);


	// ============================================================================
	// [mathpresso::ErrorCode]
	// ============================================================================

	//! MathPresso error codes.
	enum ErrorCode
	{
		//! No error.
		kErrorOk = 0,
		//! No memory.
		kErrorNoMemory = 1,
		//! Invalid argument.
		kErrorInvalidArgument,
		//! Invalid state.
		kErrorInvalidState,

		//! No expression was given.
		kErrorNoExpression,
		//! Invalid syntax.
		kErrorInvalidSyntax,

		//! Symbol not found.
		kErrorSymbolNotFound,
		//! Symbol already exists.
		kErrorSymbolAlreadyExists
	};

	// ============================================================================
	// [mathpresso::Options]
	// ============================================================================

	//! MathPresso options.
	enum Options
	{
		//! No options.
		kNoOptions = 0x00000000,

		//! Show messages and warnings.
		kOptionVerbose = 0x0001,
		//! Debug AST (shows initial and final AST).
		kOptionDebugAst = 0x0002,
		//! Debug assembly generated.
		kOptionDebugAsm = 0x0008,

		//! Do not use SSE4.1 instruction set even if CPU supports it.
		//!
		//! NOTE: This is used during testing to ensure that all code-paths produce
		//! the same results regardless of the highest instruction set used. Since
		//! SSE4.1 is the most beneficial instruction set for MathPresso there is
		//! only this option (MathPresso doesn't use SSE3 and SSSE3 at the moment).
		kOptionDisableSSE4_1 = 0x4000,

		//! \internal
		//!
		//! Mask of all accessible options, MathPresso uses also \ref InternalOptions
		//! that should not collide with \ref Options.
		_kOptionsMask = 0xFFFF
	};

	// ============================================================================
	// [mathpresso::VariableFlags]
	// ============================================================================

	//! Variable flags.
	enum VariableFlags
	{
		kVariableRW = 0x00000000,
		kVariableRO = 0x00000001,
		kVariableCplx = 0x0000002,
	};

	//! A virtual class, that is derived from by AstSymbol, MpOperation and Context.
	class MATHPRESSO_API MpObject
	{
	public:
		virtual ~MpObject()
		{
		}
	};

	// ============================================================================
	// [mathpresso::Context]
	// ============================================================================

	//! MathPresso context.
	//!
	//! Context is an environment where you can add/remove constants, variables and
	//! functions that are saved in its Symbols-database.
	//! This is a hierarchical structure, where you can add named child-contexts. You
	//! can also add hidden children, that the parent is not aware of.
	//!
	//! reading: thread-safe; writing: not thread-safe!
	struct MATHPRESSO_API Context : public MpObject, public std::enable_shared_from_this<Context>
	{
		// --------------------------------------------------------------------------
		// [Construction / Destruction]
		// --------------------------------------------------------------------------

		//! Create a new `Context` instance.
		Context() noexcept;
		//! Create a new `Context` based on `other`.
		Context(const Context& other) noexcept;

		virtual ~Context() noexcept
		{
		}
		// --------------------------------------------------------------------------
		// [Copy / Reset]
		// --------------------------------------------------------------------------

		//! Delete all symbols.
		Error reset();

		// --------------------------------------------------------------------------
		// [Interface]
		// --------------------------------------------------------------------------

		//! Add built-in intrinsics and constants.
		Error addBuiltIns(void);

		//! Add constant to this context.
		Error addConstant(const std::string & name, double value);
		Error addConstant(const std::string & name, std::complex<double> value);
		//! Add variable to this context.
		Error addVariable(const std::string &name, int offset, unsigned int flags = VariableFlags::kVariableRW);

		//! Adding Symbols to the Context, which can contain function calls. See mpoeration.h for more information.
		Error addObject(const std::string &name, std::shared_ptr<MpOperation> obj);
		//! Delete symbol from this context.
		Error delSymbol(const std::string &name);

		std::vector<std::shared_ptr<AstSymbol>> getVariables() const;

		std::shared_ptr<Context> getParent() const
		{
			return _parent.lock();
		}

		//! returns the sub-context with the given name, nullptr if it does not exist
		std::shared_ptr<Context> getChild(const std::string & name) const;

		bool isGlobal() const
		{
			return _isGlobal;
		}

		//! setter for the sub-contexts and parents.
		Error setParent(std::shared_ptr<Context> ctx);
		Error addChild(const std::string & name, std::shared_ptr<Context> ctx);
		Error delChild(const std::string & name);

		void markShadow()
		{
			_isGlobal = false;
		}
		// --------------------------------------------------------------------------
		// [Members]
		// --------------------------------------------------------------------------

		std::shared_ptr<Symbols> _symbols;
	protected:
		Error listSymbols(std::vector<std::string> &syms) const;

		std::weak_ptr<Context> _parent;
		std::map<std::string, std::shared_ptr<Context>> _children;

		bool _isGlobal;

		static constexpr uint32_t kInvalidSlot = 0xFFFFFFFFU;
	};

	// ============================================================================
	// [mathpresso::Expression]
	// ============================================================================

	//! A class that represents an expression, that was or will be compiled by mathpresso.
	struct MATHPRESSO_API Expression
	{
		MATHPRESSO_NO_COPY(Expression);

		// --------------------------------------------------------------------------
		// [Construction / Destruction]
		// --------------------------------------------------------------------------

		//! Create a new `Expression` instance.
		Expression() noexcept;
		//! Destroy the `Expression` instance.
		~Expression() noexcept;

		// --------------------------------------------------------------------------
		// [Interface]
		// --------------------------------------------------------------------------

		//! Parse and compile a given expression.
		//!
		//! \param ctx MathPresso's \ref Context to use.
		//! \param body Expression to parse and compile.
		//! \param options MathPresso options (flags), see \ref Options.
		//! \param log Used to catch messages a parser, optimizer, and compiler may
		//!        generate
		//!
		//! Returns MathPresso's error code, see \ref Error.
		Error compile(std::shared_ptr<Context> ctx, const std::string & body, unsigned int options, OutputLog* log = nullptr);

		//! Get whether the `Expression` contains a valid compiled expression.
		bool isCompiled() const;

		//! Get whether the  `expression` can returns a Complex result
		bool isComplex() const { return _isComplex; }

		//! Reset the expression.
		void reset();

		//! Evaluate expression with variable substitutions.
		//!
		//! Returns the result of the evaluated expression, NaN otherwise.
		double evaluate(void* data) const
		{
			double result[2];
			_func(result, data);

			return result[0];
		}

		//! Evaluates expression with variable substitutions.
		//!
		//! This function cannot cope with complex variables, if they are not aligned to
		//! 16 byte boundaries. Use 'alignas(16)' to force the alignment.
		std::complex<double> evaluateComplex(void* data) const
		{
			double result[2] = { 0, 0 };
			_func(result, data);

			return std::complex<double>(result[0], result[1]);
		}


		// --------------------------------------------------------------------------
		// [Members]
		// --------------------------------------------------------------------------

		//! Compiled function.
		CompiledFunc _func;


		//! True, if the result of the function could be a complex number
		bool _isComplex = false;
	};


	// ============================================================================
	// [mpsl::OutputLog]
	// ============================================================================

	//! Interface that can be used to catch compiler warnings and errors.
	struct MATHPRESSO_API OutputLog
	{
		//! Output type.
		//!
		//! Specifies how much information to return after a program is parsed/compiled.
		enum Message : unsigned int
		{
			//! Error message.
			kMessageError = 0,
			//! warning.
			kMessageWarning,
			//! AST initial.
			kMessageAstInitial,
			//! AST final.
			kMessageAstFinal,
			//! Machine code.
			kMessageAsm,
			//! For verbose output
			kMessageInfo
		};

		// --------------------------------------------------------------------------
		// [Construction / Destruction]
		// --------------------------------------------------------------------------

		OutputLog();
		virtual ~OutputLog();

		// --------------------------------------------------------------------------
		// [Interface]
		// --------------------------------------------------------------------------

		virtual void log(unsigned int type, unsigned int line, unsigned int column, const char* message, size_t len) = 0;

		void log(unsigned int type, unsigned int line, unsigned int column, const std::string & message)
		{
			log(type, line, column, message.c_str(), message.length());
		}

	};

} // mathpresso namespace

#endif // _MATHPRESSO_H
